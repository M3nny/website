import {
  fade
} from "./chunk-BZDHE263.js";
import "./chunk-RAPYA4PR.js";
import "./chunk-Y2IY7GUY.js";
import {
  SvelteComponentDev,
  add_location,
  add_render_callback,
  append_hydration_dev,
  append_styles,
  assign,
  attr_dev,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_text,
  compute_rest_props,
  create_bidirectional_transition,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  exclude_internal_props,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_update,
  group_outros,
  head_selector,
  init,
  insert_hydration_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  safe_not_equal,
  set_attributes,
  set_style,
  space,
  src_url_equal,
  text,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-UVEMIUTC.js";

// node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/general-observer.svelte
var file = "node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/general-observer.svelte";
function create_if_block_1(ctx) {
  let div;
  let div_transition;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div, file, 40, 2, 1096);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      add_render_callback(() => {
        if (!current)
          return;
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, fade, {}, true);
        div_transition.run(1);
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, fade, {}, false);
      div_transition.run(0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(40:18) ",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let div;
  let div_transition;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div, file, 36, 2, 1032);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      add_render_callback(() => {
        if (!current)
          return;
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, fade, {}, true);
        div_transition.run(1);
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, fade, {}, false);
      div_transition.run(0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(36:1) {#if disable_observer}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block, create_if_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*disable_observer*/
      ctx2[0]
    )
      return 0;
    if (
      /*loaded*/
      ctx2[1]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { "data-testid": true });
      var div_nodes = children(div);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "data-testid", "general-observer");
      add_location(div, file, 34, 0, 952);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      ctx[6](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div, null);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      ctx[6](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("General_observer", slots, ["default"]);
  let { threshold = 0.5 } = $$props;
  let { disable_observer = false } = $$props;
  let loaded = disable_observer;
  let root;
  const hasIntersectionObserver = typeof IntersectionObserver !== "undefined";
  let observer = hasIntersectionObserver && !disable_observer ? new IntersectionObserver(
    (entries) => {
      entries.forEach((entry) => {
        if (entry.intersectionRatio >= threshold) {
          $$invalidate(1, loaded = true);
          observer.disconnect();
        }
      });
    },
    { rootMargin: "0px", threshold }
  ) : null;
  onMount(() => {
    if (observer) {
      observer.observe(root);
    }
  });
  onDestroy(() => {
    if (observer) {
      observer.disconnect();
    }
  });
  const writable_props = ["threshold", "disable_observer"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<General_observer> was created with unknown prop '${key}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      root = $$value;
      $$invalidate(2, root);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("threshold" in $$props2)
      $$invalidate(3, threshold = $$props2.threshold);
    if ("disable_observer" in $$props2)
      $$invalidate(0, disable_observer = $$props2.disable_observer);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    onMount,
    fade,
    threshold,
    disable_observer,
    loaded,
    root,
    hasIntersectionObserver,
    observer
  });
  $$self.$inject_state = ($$props2) => {
    if ("threshold" in $$props2)
      $$invalidate(3, threshold = $$props2.threshold);
    if ("disable_observer" in $$props2)
      $$invalidate(0, disable_observer = $$props2.disable_observer);
    if ("loaded" in $$props2)
      $$invalidate(1, loaded = $$props2.loaded);
    if ("root" in $$props2)
      $$invalidate(2, root = $$props2.root);
    if ("observer" in $$props2)
      observer = $$props2.observer;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [disable_observer, loaded, root, threshold, $$scope, slots, div_binding];
}
var General_observer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { threshold: 3, disable_observer: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "General_observer",
      options,
      id: create_fragment.name
    });
  }
  get threshold() {
    throw new Error("<General_observer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set threshold(value) {
    throw new Error("<General_observer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disable_observer() {
    throw new Error("<General_observer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disable_observer(value) {
    throw new Error("<General_observer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var general_observer_default = General_observer;

// node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/anchor-fm.svelte
var file2 = "node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/anchor-fm.svelte";
function create_default_slot(ctx) {
  let div;
  let iframe;
  let iframe_title_value;
  let iframe_src_value;
  let iframe_style_value;
  let div_style_value;
  const block = {
    c: function create() {
      div = element("div");
      iframe = element("iframe");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      iframe = claim_element(div_nodes, "IFRAME", {
        "data-testid": true,
        title: true,
        src: true,
        frameborder: true,
        scrolling: true,
        style: true
      });
      children(iframe).forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(iframe, "data-testid", "anchor-fm-episode");
      attr_dev(iframe, "title", iframe_title_value = `anchor-fm-${/*episodeUrl*/
      ctx[0]}`);
      if (!src_url_equal(iframe.src, iframe_src_value = `https://anchor.fm/${/*episodeUrl*/
      ctx[0]}`))
        attr_dev(iframe, "src", iframe_src_value);
      attr_dev(iframe, "frameborder", "0");
      attr_dev(iframe, "scrolling", "no");
      attr_dev(iframe, "style", iframe_style_value = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      `);
      add_location(iframe, file2, 16, 2, 373);
      attr_dev(div, "class", "anchor-fm-episode-svelte-embed");
      attr_dev(div, "style", div_style_value = `
      position: relative;
      height: ${/*height*/
      ctx[1]};
      width: ${/*width*/
      ctx[2]};
    `);
      add_location(div, file2, 8, 1, 230);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, iframe);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*episodeUrl*/
      1 && iframe_title_value !== (iframe_title_value = `anchor-fm-${/*episodeUrl*/
      ctx2[0]}`)) {
        attr_dev(iframe, "title", iframe_title_value);
      }
      if (dirty & /*episodeUrl*/
      1 && !src_url_equal(iframe.src, iframe_src_value = `https://anchor.fm/${/*episodeUrl*/
      ctx2[0]}`)) {
        attr_dev(iframe, "src", iframe_src_value);
      }
      if (dirty & /*height, width*/
      6 && div_style_value !== (div_style_value = `
      position: relative;
      height: ${/*height*/
      ctx2[1]};
      width: ${/*width*/
      ctx2[2]};
    `)) {
        attr_dev(div, "style", div_style_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(8:0) <GeneralObserver {disable_observer}>",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let generalobserver;
  let current;
  generalobserver = new general_observer_default({
    props: {
      disable_observer: (
        /*disable_observer*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(generalobserver.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(generalobserver.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(generalobserver, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const generalobserver_changes = {};
      if (dirty & /*disable_observer*/
      8)
        generalobserver_changes.disable_observer = /*disable_observer*/
        ctx2[3];
      if (dirty & /*$$scope, height, width, episodeUrl*/
      23) {
        generalobserver_changes.$$scope = { dirty, ctx: ctx2 };
      }
      generalobserver.$set(generalobserver_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(generalobserver.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(generalobserver.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(generalobserver, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Anchor_fm", slots, []);
  let { episodeUrl } = $$props;
  let { height = "100px" } = $$props;
  let { width = "100%" } = $$props;
  let { disable_observer = false } = $$props;
  $$self.$$.on_mount.push(function() {
    if (episodeUrl === void 0 && !("episodeUrl" in $$props || $$self.$$.bound[$$self.$$.props["episodeUrl"]])) {
      console.warn("<Anchor_fm> was created without expected prop 'episodeUrl'");
    }
  });
  const writable_props = ["episodeUrl", "height", "width", "disable_observer"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Anchor_fm> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("episodeUrl" in $$props2)
      $$invalidate(0, episodeUrl = $$props2.episodeUrl);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
    if ("width" in $$props2)
      $$invalidate(2, width = $$props2.width);
    if ("disable_observer" in $$props2)
      $$invalidate(3, disable_observer = $$props2.disable_observer);
  };
  $$self.$capture_state = () => ({
    GeneralObserver: general_observer_default,
    episodeUrl,
    height,
    width,
    disable_observer
  });
  $$self.$inject_state = ($$props2) => {
    if ("episodeUrl" in $$props2)
      $$invalidate(0, episodeUrl = $$props2.episodeUrl);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
    if ("width" in $$props2)
      $$invalidate(2, width = $$props2.width);
    if ("disable_observer" in $$props2)
      $$invalidate(3, disable_observer = $$props2.disable_observer);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [episodeUrl, height, width, disable_observer];
}
var Anchor_fm = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      episodeUrl: 0,
      height: 1,
      width: 2,
      disable_observer: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Anchor_fm",
      options,
      id: create_fragment2.name
    });
  }
  get episodeUrl() {
    throw new Error("<Anchor_fm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set episodeUrl(value) {
    throw new Error("<Anchor_fm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Anchor_fm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Anchor_fm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Anchor_fm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Anchor_fm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disable_observer() {
    throw new Error("<Anchor_fm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disable_observer(value) {
    throw new Error("<Anchor_fm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var anchor_fm_default = Anchor_fm;

// node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/buzzsprout.svelte
var file3 = "node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/buzzsprout.svelte";
function create_default_slot2(ctx) {
  let div;
  let iframe;
  let iframe_title_value;
  let iframe_src_value;
  let iframe_style_value;
  let div_style_value;
  const block = {
    c: function create() {
      div = element("div");
      iframe = element("iframe");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      iframe = claim_element(div_nodes, "IFRAME", {
        "data-testid": true,
        title: true,
        src: true,
        frameborder: true,
        scrolling: true,
        style: true
      });
      children(iframe).forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(iframe, "data-testid", "buzzsprout");
      attr_dev(iframe, "title", iframe_title_value = `buzzsprout-${/*buzzsproutId*/
      ctx[0]}`);
      if (!src_url_equal(iframe.src, iframe_src_value = `https://www.buzzsprout.com/${/*buzzsproutId*/
      ctx[0]}?client_source=admin&amp;iframe=true`))
        attr_dev(iframe, "src", iframe_src_value);
      attr_dev(iframe, "frameborder", "0");
      attr_dev(iframe, "scrolling", "no");
      attr_dev(iframe, "style", iframe_style_value = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      `);
      add_location(iframe, file3, 16, 2, 372);
      attr_dev(div, "class", "buzzsprout-sveltekit-embed");
      attr_dev(div, "style", div_style_value = `
      position: relative; 
      height: ${/*height*/
      ctx[2]};
      width: ${/*width*/
      ctx[1]};
    `);
      add_location(div, file3, 8, 1, 232);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, iframe);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*buzzsproutId*/
      1 && iframe_title_value !== (iframe_title_value = `buzzsprout-${/*buzzsproutId*/
      ctx2[0]}`)) {
        attr_dev(iframe, "title", iframe_title_value);
      }
      if (dirty & /*buzzsproutId*/
      1 && !src_url_equal(iframe.src, iframe_src_value = `https://www.buzzsprout.com/${/*buzzsproutId*/
      ctx2[0]}?client_source=admin&amp;iframe=true`)) {
        attr_dev(iframe, "src", iframe_src_value);
      }
      if (dirty & /*height, width*/
      6 && div_style_value !== (div_style_value = `
      position: relative; 
      height: ${/*height*/
      ctx2[2]};
      width: ${/*width*/
      ctx2[1]};
    `)) {
        attr_dev(div, "style", div_style_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(8:0) <GeneralObserver {disable_observer}>",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let generalobserver;
  let current;
  generalobserver = new general_observer_default({
    props: {
      disable_observer: (
        /*disable_observer*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(generalobserver.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(generalobserver.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(generalobserver, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const generalobserver_changes = {};
      if (dirty & /*disable_observer*/
      8)
        generalobserver_changes.disable_observer = /*disable_observer*/
        ctx2[3];
      if (dirty & /*$$scope, height, width, buzzsproutId*/
      23) {
        generalobserver_changes.$$scope = { dirty, ctx: ctx2 };
      }
      generalobserver.$set(generalobserver_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(generalobserver.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(generalobserver.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(generalobserver, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Buzzsprout", slots, []);
  let { buzzsproutId } = $$props;
  let { width = "100%" } = $$props;
  let { height = "200px" } = $$props;
  let { disable_observer = false } = $$props;
  $$self.$$.on_mount.push(function() {
    if (buzzsproutId === void 0 && !("buzzsproutId" in $$props || $$self.$$.bound[$$self.$$.props["buzzsproutId"]])) {
      console.warn("<Buzzsprout> was created without expected prop 'buzzsproutId'");
    }
  });
  const writable_props = ["buzzsproutId", "width", "height", "disable_observer"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Buzzsprout> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("buzzsproutId" in $$props2)
      $$invalidate(0, buzzsproutId = $$props2.buzzsproutId);
    if ("width" in $$props2)
      $$invalidate(1, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(2, height = $$props2.height);
    if ("disable_observer" in $$props2)
      $$invalidate(3, disable_observer = $$props2.disable_observer);
  };
  $$self.$capture_state = () => ({
    GeneralObserver: general_observer_default,
    buzzsproutId,
    width,
    height,
    disable_observer
  });
  $$self.$inject_state = ($$props2) => {
    if ("buzzsproutId" in $$props2)
      $$invalidate(0, buzzsproutId = $$props2.buzzsproutId);
    if ("width" in $$props2)
      $$invalidate(1, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(2, height = $$props2.height);
    if ("disable_observer" in $$props2)
      $$invalidate(3, disable_observer = $$props2.disable_observer);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [buzzsproutId, width, height, disable_observer];
}
var Buzzsprout = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      buzzsproutId: 0,
      width: 1,
      height: 2,
      disable_observer: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Buzzsprout",
      options,
      id: create_fragment3.name
    });
  }
  get buzzsproutId() {
    throw new Error("<Buzzsprout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buzzsproutId(value) {
    throw new Error("<Buzzsprout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Buzzsprout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Buzzsprout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Buzzsprout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Buzzsprout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disable_observer() {
    throw new Error("<Buzzsprout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disable_observer(value) {
    throw new Error("<Buzzsprout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var buzzsprout_default = Buzzsprout;

// node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/code-pen.svelte
var file4 = "node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/code-pen.svelte";
function create_default_slot3(ctx) {
  let iframe;
  let iframe_title_value;
  let iframe_src_value;
  const block = {
    c: function create() {
      iframe = element("iframe");
      this.h();
    },
    l: function claim(nodes) {
      iframe = claim_element(nodes, "IFRAME", {
        class: true,
        title: true,
        src: true,
        frameborder: true,
        style: true
      });
      children(iframe).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(iframe, "class", "code-pen-sveltekit-embed");
      attr_dev(iframe, "title", iframe_title_value = `codepen-${/*codePenId*/
      ctx[0]}`);
      if (!src_url_equal(iframe.src, iframe_src_value = /*src*/
      ctx[3]))
        attr_dev(iframe, "src", iframe_src_value);
      attr_dev(iframe, "frameborder", "no");
      iframe.allowFullscreen = true;
      attr_dev(
        iframe,
        "style",
        /*iframe_styles*/
        ctx[2]
      );
      add_location(iframe, file4, 18, 1, 631);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, iframe, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*codePenId*/
      1 && iframe_title_value !== (iframe_title_value = `codepen-${/*codePenId*/
      ctx2[0]}`)) {
        attr_dev(iframe, "title", iframe_title_value);
      }
      if (dirty & /*iframe_styles*/
      4) {
        attr_dev(
          iframe,
          "style",
          /*iframe_styles*/
          ctx2[2]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(iframe);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(18:0) <GeneralObserver {disable_observer}>",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let generalobserver;
  let current;
  generalobserver = new general_observer_default({
    props: {
      disable_observer: (
        /*disable_observer*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(generalobserver.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(generalobserver.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(generalobserver, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const generalobserver_changes = {};
      if (dirty & /*disable_observer*/
      2)
        generalobserver_changes.disable_observer = /*disable_observer*/
        ctx2[1];
      if (dirty & /*$$scope, codePenId, iframe_styles*/
      2053) {
        generalobserver_changes.$$scope = { dirty, ctx: ctx2 };
      }
      generalobserver.$set(generalobserver_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(generalobserver.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(generalobserver.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(generalobserver, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Code_pen", slots, []);
  let { height = "500px" } = $$props;
  let { width = "100%" } = $$props;
  let { codePenId = "" } = $$props;
  let { tabs = "result" } = $$props;
  let { clickToLoad = true } = $$props;
  let { editable = true } = $$props;
  let { theme = "default" } = $$props;
  let { disable_observer = false } = $$props;
  let { iframe_styles = `
		height: ${height};
		width: ${width};	
	` } = $$props;
  const baseUrl = `https://codepen.io/team/codepen/embed`;
  const src = `${baseUrl}/${clickToLoad ? "/preview" : ""}/${codePenId}/?height=${height}&theme-id=${theme}&default-tab=${tabs}&editable=${editable}`;
  const writable_props = [
    "height",
    "width",
    "codePenId",
    "tabs",
    "clickToLoad",
    "editable",
    "theme",
    "disable_observer",
    "iframe_styles"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Code_pen> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("height" in $$props2)
      $$invalidate(4, height = $$props2.height);
    if ("width" in $$props2)
      $$invalidate(5, width = $$props2.width);
    if ("codePenId" in $$props2)
      $$invalidate(0, codePenId = $$props2.codePenId);
    if ("tabs" in $$props2)
      $$invalidate(6, tabs = $$props2.tabs);
    if ("clickToLoad" in $$props2)
      $$invalidate(7, clickToLoad = $$props2.clickToLoad);
    if ("editable" in $$props2)
      $$invalidate(8, editable = $$props2.editable);
    if ("theme" in $$props2)
      $$invalidate(9, theme = $$props2.theme);
    if ("disable_observer" in $$props2)
      $$invalidate(1, disable_observer = $$props2.disable_observer);
    if ("iframe_styles" in $$props2)
      $$invalidate(2, iframe_styles = $$props2.iframe_styles);
  };
  $$self.$capture_state = () => ({
    GeneralObserver: general_observer_default,
    height,
    width,
    codePenId,
    tabs,
    clickToLoad,
    editable,
    theme,
    disable_observer,
    iframe_styles,
    baseUrl,
    src
  });
  $$self.$inject_state = ($$props2) => {
    if ("height" in $$props2)
      $$invalidate(4, height = $$props2.height);
    if ("width" in $$props2)
      $$invalidate(5, width = $$props2.width);
    if ("codePenId" in $$props2)
      $$invalidate(0, codePenId = $$props2.codePenId);
    if ("tabs" in $$props2)
      $$invalidate(6, tabs = $$props2.tabs);
    if ("clickToLoad" in $$props2)
      $$invalidate(7, clickToLoad = $$props2.clickToLoad);
    if ("editable" in $$props2)
      $$invalidate(8, editable = $$props2.editable);
    if ("theme" in $$props2)
      $$invalidate(9, theme = $$props2.theme);
    if ("disable_observer" in $$props2)
      $$invalidate(1, disable_observer = $$props2.disable_observer);
    if ("iframe_styles" in $$props2)
      $$invalidate(2, iframe_styles = $$props2.iframe_styles);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    codePenId,
    disable_observer,
    iframe_styles,
    src,
    height,
    width,
    tabs,
    clickToLoad,
    editable,
    theme
  ];
}
var Code_pen = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, {
      height: 4,
      width: 5,
      codePenId: 0,
      tabs: 6,
      clickToLoad: 7,
      editable: 8,
      theme: 9,
      disable_observer: 1,
      iframe_styles: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Code_pen",
      options,
      id: create_fragment4.name
    });
  }
  get height() {
    throw new Error("<Code_pen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Code_pen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Code_pen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Code_pen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get codePenId() {
    throw new Error("<Code_pen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set codePenId(value) {
    throw new Error("<Code_pen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabs() {
    throw new Error("<Code_pen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabs(value) {
    throw new Error("<Code_pen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clickToLoad() {
    throw new Error("<Code_pen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clickToLoad(value) {
    throw new Error("<Code_pen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get editable() {
    throw new Error("<Code_pen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set editable(value) {
    throw new Error("<Code_pen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<Code_pen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Code_pen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disable_observer() {
    throw new Error("<Code_pen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disable_observer(value) {
    throw new Error("<Code_pen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iframe_styles() {
    throw new Error("<Code_pen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iframe_styles(value) {
    throw new Error("<Code_pen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var code_pen_default = Code_pen;

// node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/deezer.svelte
var file5 = "node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/deezer.svelte";
function create_default_slot4(ctx) {
  let iframe;
  let iframe_src_value;
  const block = {
    c: function create() {
      iframe = element("iframe");
      this.h();
    },
    l: function claim(nodes) {
      iframe = claim_element(nodes, "IFRAME", {
        title: true,
        src: true,
        frameborder: true,
        allowtransparency: true,
        allow: true,
        style: true
      });
      children(iframe).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(iframe, "title", "deezer-widget");
      if (!src_url_equal(iframe.src, iframe_src_value = `https://widget.deezer.com/widget/${/*theme*/
      ctx[0]}/${/*frameSrc*/
      ctx[1]}`))
        attr_dev(iframe, "src", iframe_src_value);
      attr_dev(iframe, "frameborder", "0");
      attr_dev(iframe, "allowtransparency", "");
      attr_dev(iframe, "allow", "encrypted-media; clipboard-write");
      attr_dev(
        iframe,
        "style",
        /*iframe_styles*/
        ctx[3]
      );
      add_location(iframe, file5, 14, 1, 359);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, iframe, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*theme, frameSrc*/
      3 && !src_url_equal(iframe.src, iframe_src_value = `https://widget.deezer.com/widget/${/*theme*/
      ctx2[0]}/${/*frameSrc*/
      ctx2[1]}`)) {
        attr_dev(iframe, "src", iframe_src_value);
      }
      if (dirty & /*iframe_styles*/
      8) {
        attr_dev(
          iframe,
          "style",
          /*iframe_styles*/
          ctx2[3]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(iframe);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: "(14:0) <GeneralObserver {disable_observer}>",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let generalobserver;
  let current;
  generalobserver = new general_observer_default({
    props: {
      disable_observer: (
        /*disable_observer*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(generalobserver.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(generalobserver.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(generalobserver, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const generalobserver_changes = {};
      if (dirty & /*disable_observer*/
      4)
        generalobserver_changes.disable_observer = /*disable_observer*/
        ctx2[2];
      if (dirty & /*$$scope, theme, frameSrc, iframe_styles*/
      75) {
        generalobserver_changes.$$scope = { dirty, ctx: ctx2 };
      }
      generalobserver.$set(generalobserver_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(generalobserver.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(generalobserver.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(generalobserver, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Deezer", slots, []);
  let { theme = "auto" } = $$props;
  let { frameSrc = "" } = $$props;
  let { height = "300px" } = $$props;
  let { width = "100%" } = $$props;
  let { disable_observer = false } = $$props;
  let { iframe_styles = `
		border-radius: 0.6rem;
		height: ${height};
		width: ${width};	
	` } = $$props;
  const writable_props = ["theme", "frameSrc", "height", "width", "disable_observer", "iframe_styles"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Deezer> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("frameSrc" in $$props2)
      $$invalidate(1, frameSrc = $$props2.frameSrc);
    if ("height" in $$props2)
      $$invalidate(4, height = $$props2.height);
    if ("width" in $$props2)
      $$invalidate(5, width = $$props2.width);
    if ("disable_observer" in $$props2)
      $$invalidate(2, disable_observer = $$props2.disable_observer);
    if ("iframe_styles" in $$props2)
      $$invalidate(3, iframe_styles = $$props2.iframe_styles);
  };
  $$self.$capture_state = () => ({
    GeneralObserver: general_observer_default,
    theme,
    frameSrc,
    height,
    width,
    disable_observer,
    iframe_styles
  });
  $$self.$inject_state = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("frameSrc" in $$props2)
      $$invalidate(1, frameSrc = $$props2.frameSrc);
    if ("height" in $$props2)
      $$invalidate(4, height = $$props2.height);
    if ("width" in $$props2)
      $$invalidate(5, width = $$props2.width);
    if ("disable_observer" in $$props2)
      $$invalidate(2, disable_observer = $$props2.disable_observer);
    if ("iframe_styles" in $$props2)
      $$invalidate(3, iframe_styles = $$props2.iframe_styles);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [theme, frameSrc, disable_observer, iframe_styles, height, width];
}
var Deezer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, {
      theme: 0,
      frameSrc: 1,
      height: 4,
      width: 5,
      disable_observer: 2,
      iframe_styles: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Deezer",
      options,
      id: create_fragment5.name
    });
  }
  get theme() {
    throw new Error("<Deezer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Deezer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frameSrc() {
    throw new Error("<Deezer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frameSrc(value) {
    throw new Error("<Deezer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Deezer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Deezer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Deezer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Deezer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disable_observer() {
    throw new Error("<Deezer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disable_observer(value) {
    throw new Error("<Deezer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iframe_styles() {
    throw new Error("<Deezer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iframe_styles(value) {
    throw new Error("<Deezer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var deezer_default = Deezer;

// node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/generic-embed.svelte
var file6 = "node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/generic-embed.svelte";
function create_default_slot5(ctx) {
  let iframe;
  let iframe_src_value;
  let t;
  let current;
  let iframe_levels = [
    { src: iframe_src_value = /*src*/
    ctx[0] },
    { width: (
      /*width*/
      ctx[3]
    ) },
    { height: (
      /*height*/
      ctx[2]
    ) },
    { title: (
      /*title*/
      ctx[1]
    ) },
    /*$$restProps*/
    ctx[5]
  ];
  let iframe_data = {};
  for (let i = 0; i < iframe_levels.length; i += 1) {
    iframe_data = assign(iframe_data, iframe_levels[i]);
  }
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  const block = {
    c: function create() {
      iframe = element("iframe");
      t = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      iframe = claim_element(nodes, "IFRAME", {
        src: true,
        width: true,
        height: true,
        title: true
      });
      children(iframe).forEach(detach_dev);
      t = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
      this.h();
    },
    h: function hydrate() {
      set_attributes(iframe, iframe_data);
      add_location(iframe, file6, 9, 1, 251);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, iframe, anchor);
      insert_hydration_dev(target, t, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      set_attributes(iframe, iframe_data = get_spread_update(iframe_levels, [
        (!current || dirty & /*src*/
        1 && !src_url_equal(iframe.src, iframe_src_value = /*src*/
        ctx2[0])) && { src: iframe_src_value },
        (!current || dirty & /*width*/
        8) && { width: (
          /*width*/
          ctx2[3]
        ) },
        (!current || dirty & /*height*/
        4) && { height: (
          /*height*/
          ctx2[2]
        ) },
        (!current || dirty & /*title*/
        2) && { title: (
          /*title*/
          ctx2[1]
        ) },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5]
      ]));
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(iframe);
      if (detaching)
        detach_dev(t);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot5.name,
    type: "slot",
    source: "(9:0) <GeneralObserver {disable_observer}>",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let generalobserver;
  let current;
  generalobserver = new general_observer_default({
    props: {
      disable_observer: (
        /*disable_observer*/
        ctx[4]
      ),
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(generalobserver.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(generalobserver.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(generalobserver, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const generalobserver_changes = {};
      if (dirty & /*disable_observer*/
      16)
        generalobserver_changes.disable_observer = /*disable_observer*/
        ctx2[4];
      if (dirty & /*$$scope, src, width, height, title, $$restProps*/
      175) {
        generalobserver_changes.$$scope = { dirty, ctx: ctx2 };
      }
      generalobserver.$set(generalobserver_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(generalobserver.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(generalobserver.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(generalobserver, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  const omit_props_names = ["src", "title", "height", "width", "disable_observer"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Generic_embed", slots, ["default"]);
  let { src = "" } = $$props;
  let { title = "" } = $$props;
  let { height = "152px" } = $$props;
  let { width = "100%" } = $$props;
  let { disable_observer = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("src" in $$new_props)
      $$invalidate(0, src = $$new_props.src);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
    if ("height" in $$new_props)
      $$invalidate(2, height = $$new_props.height);
    if ("width" in $$new_props)
      $$invalidate(3, width = $$new_props.width);
    if ("disable_observer" in $$new_props)
      $$invalidate(4, disable_observer = $$new_props.disable_observer);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    GeneralObserver: general_observer_default,
    src,
    title,
    height,
    width,
    disable_observer
  });
  $$self.$inject_state = ($$new_props) => {
    if ("src" in $$props)
      $$invalidate(0, src = $$new_props.src);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("height" in $$props)
      $$invalidate(2, height = $$new_props.height);
    if ("width" in $$props)
      $$invalidate(3, width = $$new_props.width);
    if ("disable_observer" in $$props)
      $$invalidate(4, disable_observer = $$new_props.disable_observer);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [src, title, height, width, disable_observer, $$restProps, slots, $$scope];
}
var Generic_embed = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, {
      src: 0,
      title: 1,
      height: 2,
      width: 3,
      disable_observer: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Generic_embed",
      options,
      id: create_fragment6.name
    });
  }
  get src() {
    throw new Error("<Generic_embed>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set src(value) {
    throw new Error("<Generic_embed>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Generic_embed>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Generic_embed>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Generic_embed>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Generic_embed>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Generic_embed>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Generic_embed>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disable_observer() {
    throw new Error("<Generic_embed>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disable_observer(value) {
    throw new Error("<Generic_embed>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var generic_embed_default = Generic_embed;

// node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/gist.svelte
var file7 = "node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/gist.svelte";
function add_css(target) {
  append_styles(target, "svelte-fhy76t", "iframe.svelte-fhy76t{border:0;width:100%;height:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2lzdC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBb0JDLG9CQUFPLENBQ04sTUFBTSxDQUFFLENBQUMsQ0FDVCxLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxJQUNUIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbImdpc3Quc3ZlbHRlIl19 */");
}
function create_default_slot6(ctx) {
  let iframe;
  let iframe_src_value;
  const block = {
    c: function create() {
      iframe = element("iframe");
      this.h();
    },
    l: function claim(nodes) {
      iframe = claim_element(nodes, "IFRAME", {
        title: true,
        src: true,
        style: true,
        class: true
      });
      children(iframe).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(iframe, "title", "gist-widget");
      if (!src_url_equal(iframe.src, iframe_src_value = "https://gist.github.com/" + /*gistUri*/
      ctx[0] + ".pibb"))
        attr_dev(iframe, "src", iframe_src_value);
      attr_dev(
        iframe,
        "style",
        /*iframe_styles*/
        ctx[2]
      );
      attr_dev(iframe, "class", "svelte-fhy76t");
      add_location(iframe, file7, 12, 1, 305);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, iframe, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*gistUri*/
      1 && !src_url_equal(iframe.src, iframe_src_value = "https://gist.github.com/" + /*gistUri*/
      ctx2[0] + ".pibb")) {
        attr_dev(iframe, "src", iframe_src_value);
      }
      if (dirty & /*iframe_styles*/
      4) {
        attr_dev(
          iframe,
          "style",
          /*iframe_styles*/
          ctx2[2]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(iframe);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot6.name,
    type: "slot",
    source: "(12:0) <GeneralObserver {disable_observer}>",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let generalobserver;
  let current;
  generalobserver = new general_observer_default({
    props: {
      disable_observer: (
        /*disable_observer*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot6] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(generalobserver.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(generalobserver.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(generalobserver, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const generalobserver_changes = {};
      if (dirty & /*disable_observer*/
      2)
        generalobserver_changes.disable_observer = /*disable_observer*/
        ctx2[1];
      if (dirty & /*$$scope, gistUri, iframe_styles*/
      37) {
        generalobserver_changes.$$scope = { dirty, ctx: ctx2 };
      }
      generalobserver.$set(generalobserver_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(generalobserver.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(generalobserver.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(generalobserver, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Gist", slots, []);
  let { width = "100%" } = $$props;
  let { height = "320px" } = $$props;
  let { gistUri = "" } = $$props;
  let { disable_observer = false } = $$props;
  let { iframe_styles = `
		height: ${height};
		width: ${width};
	` } = $$props;
  const writable_props = ["width", "height", "gistUri", "disable_observer", "iframe_styles"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Gist> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(3, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(4, height = $$props2.height);
    if ("gistUri" in $$props2)
      $$invalidate(0, gistUri = $$props2.gistUri);
    if ("disable_observer" in $$props2)
      $$invalidate(1, disable_observer = $$props2.disable_observer);
    if ("iframe_styles" in $$props2)
      $$invalidate(2, iframe_styles = $$props2.iframe_styles);
  };
  $$self.$capture_state = () => ({
    GeneralObserver: general_observer_default,
    width,
    height,
    gistUri,
    disable_observer,
    iframe_styles
  });
  $$self.$inject_state = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(3, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(4, height = $$props2.height);
    if ("gistUri" in $$props2)
      $$invalidate(0, gistUri = $$props2.gistUri);
    if ("disable_observer" in $$props2)
      $$invalidate(1, disable_observer = $$props2.disable_observer);
    if ("iframe_styles" in $$props2)
      $$invalidate(2, iframe_styles = $$props2.iframe_styles);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [gistUri, disable_observer, iframe_styles, width, height];
}
var Gist = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance7,
      create_fragment7,
      safe_not_equal,
      {
        width: 3,
        height: 4,
        gistUri: 0,
        disable_observer: 1,
        iframe_styles: 2
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Gist",
      options,
      id: create_fragment7.name
    });
  }
  get width() {
    throw new Error("<Gist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Gist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Gist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Gist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gistUri() {
    throw new Error("<Gist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gistUri(value) {
    throw new Error("<Gist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disable_observer() {
    throw new Error("<Gist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disable_observer(value) {
    throw new Error("<Gist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iframe_styles() {
    throw new Error("<Gist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iframe_styles(value) {
    throw new Error("<Gist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var gist_default = Gist;

// node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/guild.svelte
var file8 = "node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/guild.svelte";
function create_default_slot7(ctx) {
  let div;
  let iframe;
  let iframe_title_value;
  let iframe_src_value;
  let iframe_style_value;
  let div_style_value;
  const block = {
    c: function create() {
      div = element("div");
      iframe = element("iframe");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      iframe = claim_element(div_nodes, "IFRAME", {
        "data-testid": true,
        title: true,
        src: true,
        height: true,
        width: true,
        frameborder: true,
        scrolling: true,
        style: true
      });
      children(iframe).forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(iframe, "data-testid", "guild-card");
      attr_dev(iframe, "title", iframe_title_value = `guild-card-${/*card_id*/
      ctx[2]}`);
      if (!src_url_equal(iframe.src, iframe_src_value = `https://beta.guild.host/embeds/${/*type*/
      ctx[3]}/${/*card_id*/
      ctx[2]}/${/*display_type*/
      ctx[4]}`))
        attr_dev(iframe, "src", iframe_src_value);
      attr_dev(
        iframe,
        "height",
        /*height*/
        ctx[0]
      );
      attr_dev(
        iframe,
        "width",
        /*width*/
        ctx[1]
      );
      attr_dev(iframe, "frameborder", "0");
      attr_dev(iframe, "scrolling", "no");
      attr_dev(iframe, "style", iframe_style_value = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border-radius: 0.5rem;
      `);
      add_location(iframe, file8, 43, 2, 1812);
      attr_dev(div, "class", "guild-card");
      attr_dev(div, "style", div_style_value = `
      position: relative;
      height: ${/*height*/
      ctx[0]};
      width: ${/*width*/
      ctx[1]};
    `);
      add_location(div, file8, 35, 1, 1689);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, iframe);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*card_id*/
      4 && iframe_title_value !== (iframe_title_value = `guild-card-${/*card_id*/
      ctx2[2]}`)) {
        attr_dev(iframe, "title", iframe_title_value);
      }
      if (dirty & /*type, card_id, display_type*/
      28 && !src_url_equal(iframe.src, iframe_src_value = `https://beta.guild.host/embeds/${/*type*/
      ctx2[3]}/${/*card_id*/
      ctx2[2]}/${/*display_type*/
      ctx2[4]}`)) {
        attr_dev(iframe, "src", iframe_src_value);
      }
      if (dirty & /*height*/
      1) {
        attr_dev(
          iframe,
          "height",
          /*height*/
          ctx2[0]
        );
      }
      if (dirty & /*width*/
      2) {
        attr_dev(
          iframe,
          "width",
          /*width*/
          ctx2[1]
        );
      }
      if (dirty & /*height, width*/
      3 && div_style_value !== (div_style_value = `
      position: relative;
      height: ${/*height*/
      ctx2[0]};
      width: ${/*width*/
      ctx2[1]};
    `)) {
        attr_dev(div, "style", div_style_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot7.name,
    type: "slot",
    source: "(35:0) <GeneralObserver {disable_observer}>",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let generalobserver;
  let current;
  generalobserver = new general_observer_default({
    props: {
      disable_observer: (
        /*disable_observer*/
        ctx[5]
      ),
      $$slots: { default: [create_default_slot7] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(generalobserver.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(generalobserver.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(generalobserver, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const generalobserver_changes = {};
      if (dirty & /*disable_observer*/
      32)
        generalobserver_changes.disable_observer = /*disable_observer*/
        ctx2[5];
      if (dirty & /*$$scope, height, width, card_id, type, display_type*/
      95) {
        generalobserver_changes.$$scope = { dirty, ctx: ctx2 };
      }
      generalobserver.$set(generalobserver_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(generalobserver.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(generalobserver.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(generalobserver, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Guild", slots, []);
  let { height = "380px" } = $$props;
  let { width = "100%" } = $$props;
  let { card_id } = $$props;
  let { type = "guild" } = $$props;
  let { display_type = "card" } = $$props;
  let { disable_observer = false } = $$props;
  $$self.$$.on_mount.push(function() {
    if (card_id === void 0 && !("card_id" in $$props || $$self.$$.bound[$$self.$$.props["card_id"]])) {
      console.warn("<Guild> was created without expected prop 'card_id'");
    }
  });
  const writable_props = ["height", "width", "card_id", "type", "display_type", "disable_observer"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Guild> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("height" in $$props2)
      $$invalidate(0, height = $$props2.height);
    if ("width" in $$props2)
      $$invalidate(1, width = $$props2.width);
    if ("card_id" in $$props2)
      $$invalidate(2, card_id = $$props2.card_id);
    if ("type" in $$props2)
      $$invalidate(3, type = $$props2.type);
    if ("display_type" in $$props2)
      $$invalidate(4, display_type = $$props2.display_type);
    if ("disable_observer" in $$props2)
      $$invalidate(5, disable_observer = $$props2.disable_observer);
  };
  $$self.$capture_state = () => ({
    GeneralObserver: general_observer_default,
    height,
    width,
    card_id,
    type,
    display_type,
    disable_observer
  });
  $$self.$inject_state = ($$props2) => {
    if ("height" in $$props2)
      $$invalidate(0, height = $$props2.height);
    if ("width" in $$props2)
      $$invalidate(1, width = $$props2.width);
    if ("card_id" in $$props2)
      $$invalidate(2, card_id = $$props2.card_id);
    if ("type" in $$props2)
      $$invalidate(3, type = $$props2.type);
    if ("display_type" in $$props2)
      $$invalidate(4, display_type = $$props2.display_type);
    if ("disable_observer" in $$props2)
      $$invalidate(5, disable_observer = $$props2.disable_observer);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [height, width, card_id, type, display_type, disable_observer];
}
var Guild = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, {
      height: 0,
      width: 1,
      card_id: 2,
      type: 3,
      display_type: 4,
      disable_observer: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Guild",
      options,
      id: create_fragment8.name
    });
  }
  get height() {
    throw new Error("<Guild>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Guild>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Guild>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Guild>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get card_id() {
    throw new Error("<Guild>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set card_id(value) {
    throw new Error("<Guild>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Guild>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Guild>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get display_type() {
    throw new Error("<Guild>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set display_type(value) {
    throw new Error("<Guild>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disable_observer() {
    throw new Error("<Guild>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disable_observer(value) {
    throw new Error("<Guild>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var guild_default = Guild;

// node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/relive.svelte
var file9 = "node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/relive.svelte";
function create_default_slot8(ctx) {
  let div;
  let iframe;
  let iframe_title_value;
  let iframe_src_value;
  let iframe_style_value;
  let div_style_value;
  const block = {
    c: function create() {
      div = element("div");
      iframe = element("iframe");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { style: true });
      var div_nodes = children(div);
      iframe = claim_element(div_nodes, "IFRAME", {
        title: true,
        src: true,
        scrolling: true,
        frameborder: true,
        style: true
      });
      children(iframe).forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(iframe, "title", iframe_title_value = `relive-${/*reliveId*/
      ctx[0]}`);
      if (!src_url_equal(iframe.src, iframe_src_value = `https://www.relive.cc/view/${/*reliveId*/
      ctx[0]}/widget`))
        attr_dev(iframe, "src", iframe_src_value);
      attr_dev(iframe, "scrolling", "no");
      attr_dev(iframe, "frameborder", "0");
      iframe.allowFullscreen = true;
      attr_dev(iframe, "style", iframe_style_value = `
        position: absolute;
        top: -${defaultMargin}px;
        left: -${defaultMargin}px;
        width: calc(100% + ${defaultMargin * 2}px);
        height: calc(100% + ${defaultMargin * 2}px);
      `);
      add_location(iframe, file9, 16, 2, 362);
      attr_dev(div, "style", div_style_value = `
      position: relative;
      width: ${/*width*/
      ctx[1]};
      aspect-ratio: 1 / 0.7825;
      overflow: hidden;
    `);
      add_location(div, file9, 8, 1, 229);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, iframe);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*reliveId*/
      1 && iframe_title_value !== (iframe_title_value = `relive-${/*reliveId*/
      ctx2[0]}`)) {
        attr_dev(iframe, "title", iframe_title_value);
      }
      if (dirty & /*reliveId*/
      1 && !src_url_equal(iframe.src, iframe_src_value = `https://www.relive.cc/view/${/*reliveId*/
      ctx2[0]}/widget`)) {
        attr_dev(iframe, "src", iframe_src_value);
      }
      if (dirty & /*width*/
      2 && div_style_value !== (div_style_value = `
      position: relative;
      width: ${/*width*/
      ctx2[1]};
      aspect-ratio: 1 / 0.7825;
      overflow: hidden;
    `)) {
        attr_dev(div, "style", div_style_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot8.name,
    type: "slot",
    source: "(8:0) <GeneralObserver {disable_observer}>",
    ctx
  });
  return block;
}
function create_fragment9(ctx) {
  let generalobserver;
  let current;
  generalobserver = new general_observer_default({
    props: {
      disable_observer: (
        /*disable_observer*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot8] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(generalobserver.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(generalobserver.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(generalobserver, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const generalobserver_changes = {};
      if (dirty & /*disable_observer*/
      4)
        generalobserver_changes.disable_observer = /*disable_observer*/
        ctx2[2];
      if (dirty & /*$$scope, width, reliveId*/
      11) {
        generalobserver_changes.$$scope = { dirty, ctx: ctx2 };
      }
      generalobserver.$set(generalobserver_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(generalobserver.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(generalobserver.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(generalobserver, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var defaultMargin = 2;
function instance9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Relive", slots, []);
  let { reliveId = "" } = $$props;
  let { width = "100%" } = $$props;
  let { disable_observer = false } = $$props;
  const writable_props = ["reliveId", "width", "disable_observer"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Relive> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("reliveId" in $$props2)
      $$invalidate(0, reliveId = $$props2.reliveId);
    if ("width" in $$props2)
      $$invalidate(1, width = $$props2.width);
    if ("disable_observer" in $$props2)
      $$invalidate(2, disable_observer = $$props2.disable_observer);
  };
  $$self.$capture_state = () => ({
    GeneralObserver: general_observer_default,
    reliveId,
    width,
    disable_observer,
    defaultMargin
  });
  $$self.$inject_state = ($$props2) => {
    if ("reliveId" in $$props2)
      $$invalidate(0, reliveId = $$props2.reliveId);
    if ("width" in $$props2)
      $$invalidate(1, width = $$props2.width);
    if ("disable_observer" in $$props2)
      $$invalidate(2, disable_observer = $$props2.disable_observer);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [reliveId, width, disable_observer];
}
var Relive = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, {
      reliveId: 0,
      width: 1,
      disable_observer: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Relive",
      options,
      id: create_fragment9.name
    });
  }
  get reliveId() {
    throw new Error("<Relive>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set reliveId(value) {
    throw new Error("<Relive>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Relive>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Relive>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disable_observer() {
    throw new Error("<Relive>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disable_observer(value) {
    throw new Error("<Relive>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var relive_default = Relive;

// node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/simple-cast.svelte
var file10 = "node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/simple-cast.svelte";
function create_default_slot9(ctx) {
  let div;
  let iframe;
  let iframe_title_value;
  let iframe_src_value;
  let iframe_style_value;
  let div_style_value;
  const block = {
    c: function create() {
      div = element("div");
      iframe = element("iframe");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      iframe = claim_element(div_nodes, "IFRAME", {
        "data-testid": true,
        title: true,
        src: true,
        frameborder: true,
        scrolling: true,
        seamless: true,
        style: true
      });
      children(iframe).forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(iframe, "data-testid", "simplecast-episode");
      attr_dev(iframe, "title", iframe_title_value = `simplecast-${/*episodeId*/
      ctx[0]}`);
      if (!src_url_equal(iframe.src, iframe_src_value = `https://player.simplecast.com/${/*episodeId*/
      ctx[0]}${/*theme*/
      ctx[1] === `dark` ? `?dark=true` : ``}`))
        attr_dev(iframe, "src", iframe_src_value);
      attr_dev(iframe, "frameborder", "no");
      attr_dev(iframe, "scrolling", "no");
      attr_dev(iframe, "seamless", "");
      attr_dev(iframe, "style", iframe_style_value = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      `);
      add_location(iframe, file10, 15, 2, 341);
      attr_dev(div, "class", "simplecast-episode-svelte-embed");
      attr_dev(div, "style", div_style_value = `
      position: relative;
      height: 200px;
      width: 100%;
    `);
      add_location(div, file10, 7, 1, 205);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, iframe);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*episodeId*/
      1 && iframe_title_value !== (iframe_title_value = `simplecast-${/*episodeId*/
      ctx2[0]}`)) {
        attr_dev(iframe, "title", iframe_title_value);
      }
      if (dirty & /*episodeId, theme*/
      3 && !src_url_equal(iframe.src, iframe_src_value = `https://player.simplecast.com/${/*episodeId*/
      ctx2[0]}${/*theme*/
      ctx2[1] === `dark` ? `?dark=true` : ``}`)) {
        attr_dev(iframe, "src", iframe_src_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot9.name,
    type: "slot",
    source: "(7:0) <GeneralObserver {disable_observer}>",
    ctx
  });
  return block;
}
function create_fragment10(ctx) {
  let generalobserver;
  let current;
  generalobserver = new general_observer_default({
    props: {
      disable_observer: (
        /*disable_observer*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot9] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(generalobserver.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(generalobserver.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(generalobserver, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const generalobserver_changes = {};
      if (dirty & /*disable_observer*/
      4)
        generalobserver_changes.disable_observer = /*disable_observer*/
        ctx2[2];
      if (dirty & /*$$scope, episodeId, theme*/
      11) {
        generalobserver_changes.$$scope = { dirty, ctx: ctx2 };
      }
      generalobserver.$set(generalobserver_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(generalobserver.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(generalobserver.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(generalobserver, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Simple_cast", slots, []);
  let { episodeId = "" } = $$props;
  let { theme = `dark` } = $$props;
  let { disable_observer = false } = $$props;
  const writable_props = ["episodeId", "theme", "disable_observer"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Simple_cast> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("episodeId" in $$props2)
      $$invalidate(0, episodeId = $$props2.episodeId);
    if ("theme" in $$props2)
      $$invalidate(1, theme = $$props2.theme);
    if ("disable_observer" in $$props2)
      $$invalidate(2, disable_observer = $$props2.disable_observer);
  };
  $$self.$capture_state = () => ({
    GeneralObserver: general_observer_default,
    episodeId,
    theme,
    disable_observer
  });
  $$self.$inject_state = ($$props2) => {
    if ("episodeId" in $$props2)
      $$invalidate(0, episodeId = $$props2.episodeId);
    if ("theme" in $$props2)
      $$invalidate(1, theme = $$props2.theme);
    if ("disable_observer" in $$props2)
      $$invalidate(2, disable_observer = $$props2.disable_observer);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [episodeId, theme, disable_observer];
}
var Simple_cast = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, {
      episodeId: 0,
      theme: 1,
      disable_observer: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Simple_cast",
      options,
      id: create_fragment10.name
    });
  }
  get episodeId() {
    throw new Error("<Simple_cast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set episodeId(value) {
    throw new Error("<Simple_cast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<Simple_cast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Simple_cast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disable_observer() {
    throw new Error("<Simple_cast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disable_observer(value) {
    throw new Error("<Simple_cast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var simple_cast_default = Simple_cast;

// node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/slides.svelte
var file11 = "node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/slides.svelte";
function create_default_slot10(ctx) {
  let iframe;
  let iframe_src_value;
  const block = {
    c: function create() {
      iframe = element("iframe");
      this.h();
    },
    l: function claim(nodes) {
      iframe = claim_element(nodes, "IFRAME", {
        src: true,
        width: true,
        height: true,
        title: true,
        scrolling: true,
        frameborder: true,
        style: true
      });
      children(iframe).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      if (!src_url_equal(iframe.src, iframe_src_value = /*src*/
      ctx[4]))
        attr_dev(iframe, "src", iframe_src_value);
      attr_dev(
        iframe,
        "width",
        /*width*/
        ctx[0]
      );
      attr_dev(
        iframe,
        "height",
        /*height*/
        ctx[1]
      );
      attr_dev(
        iframe,
        "title",
        /*title*/
        ctx[2]
      );
      attr_dev(iframe, "scrolling", "no");
      attr_dev(iframe, "frameborder", "0");
      iframe.allowFullscreen = true;
      set_style(iframe, "width", "100%");
      add_location(iframe, file11, 20, 1, 560);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, iframe, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*width*/
      1) {
        attr_dev(
          iframe,
          "width",
          /*width*/
          ctx2[0]
        );
      }
      if (dirty & /*height*/
      2) {
        attr_dev(
          iframe,
          "height",
          /*height*/
          ctx2[1]
        );
      }
      if (dirty & /*title*/
      4) {
        attr_dev(
          iframe,
          "title",
          /*title*/
          ctx2[2]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(iframe);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot10.name,
    type: "slot",
    source: "(20:0) <GeneralObserver {disable_observer}>",
    ctx
  });
  return block;
}
function create_fragment11(ctx) {
  let generalobserver;
  let current;
  generalobserver = new general_observer_default({
    props: {
      disable_observer: (
        /*disable_observer*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot10] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(generalobserver.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(generalobserver.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(generalobserver, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const generalobserver_changes = {};
      if (dirty & /*disable_observer*/
      8)
        generalobserver_changes.disable_observer = /*disable_observer*/
        ctx2[3];
      if (dirty & /*$$scope, width, height, title*/
      4103) {
        generalobserver_changes.$$scope = { dirty, ctx: ctx2 };
      }
      generalobserver.$set(generalobserver_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(generalobserver.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(generalobserver.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(generalobserver, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Slides", slots, []);
  let { width = "100%" } = $$props;
  let { height = "420px" } = $$props;
  let { username = "" } = $$props;
  let { title = "" } = $$props;
  let { byline = "hidden" } = $$props;
  let { share = "hidden" } = $$props;
  let { style = "dark" } = $$props;
  let { disable_observer = false } = $$props;
  let baseUrl = `https://slides.com/${username}/${title}/embed?`;
  const config2 = { style, byline, share };
  const queryString = new URLSearchParams(config2);
  const src = `${baseUrl}&${queryString.toString()}`;
  const writable_props = [
    "width",
    "height",
    "username",
    "title",
    "byline",
    "share",
    "style",
    "disable_observer"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Slides> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
    if ("username" in $$props2)
      $$invalidate(5, username = $$props2.username);
    if ("title" in $$props2)
      $$invalidate(2, title = $$props2.title);
    if ("byline" in $$props2)
      $$invalidate(6, byline = $$props2.byline);
    if ("share" in $$props2)
      $$invalidate(7, share = $$props2.share);
    if ("style" in $$props2)
      $$invalidate(8, style = $$props2.style);
    if ("disable_observer" in $$props2)
      $$invalidate(3, disable_observer = $$props2.disable_observer);
  };
  $$self.$capture_state = () => ({
    GeneralObserver: general_observer_default,
    width,
    height,
    username,
    title,
    byline,
    share,
    style,
    disable_observer,
    baseUrl,
    config: config2,
    queryString,
    src
  });
  $$self.$inject_state = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
    if ("username" in $$props2)
      $$invalidate(5, username = $$props2.username);
    if ("title" in $$props2)
      $$invalidate(2, title = $$props2.title);
    if ("byline" in $$props2)
      $$invalidate(6, byline = $$props2.byline);
    if ("share" in $$props2)
      $$invalidate(7, share = $$props2.share);
    if ("style" in $$props2)
      $$invalidate(8, style = $$props2.style);
    if ("disable_observer" in $$props2)
      $$invalidate(3, disable_observer = $$props2.disable_observer);
    if ("baseUrl" in $$props2)
      baseUrl = $$props2.baseUrl;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [width, height, title, disable_observer, src, username, byline, share, style];
}
var Slides = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, {
      width: 0,
      height: 1,
      username: 5,
      title: 2,
      byline: 6,
      share: 7,
      style: 8,
      disable_observer: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Slides",
      options,
      id: create_fragment11.name
    });
  }
  get width() {
    throw new Error("<Slides>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Slides>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Slides>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Slides>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get username() {
    throw new Error("<Slides>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set username(value) {
    throw new Error("<Slides>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Slides>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Slides>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get byline() {
    throw new Error("<Slides>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set byline(value) {
    throw new Error("<Slides>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get share() {
    throw new Error("<Slides>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set share(value) {
    throw new Error("<Slides>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Slides>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Slides>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disable_observer() {
    throw new Error("<Slides>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disable_observer(value) {
    throw new Error("<Slides>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var slides_default = Slides;

// node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/sound-cloud.svelte
var file12 = "node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/sound-cloud.svelte";
function create_default_slot11(ctx) {
  let iframe;
  let iframe_title_value;
  let iframe_src_value;
  const block = {
    c: function create() {
      iframe = element("iframe");
      this.h();
    },
    l: function claim(nodes) {
      iframe = claim_element(nodes, "IFRAME", {
        width: true,
        height: true,
        title: true,
        scrolling: true,
        frameborder: true,
        allow: true,
        src: true,
        style: true
      });
      children(iframe).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        iframe,
        "width",
        /*width*/
        ctx[1]
      );
      attr_dev(
        iframe,
        "height",
        /*height*/
        ctx[2]
      );
      attr_dev(iframe, "title", iframe_title_value = `soundcloud-${/*soundcloudLink*/
      ctx[0]}`);
      attr_dev(iframe, "scrolling", "false");
      attr_dev(iframe, "frameborder", "0");
      attr_dev(iframe, "allow", "autoplay");
      if (!src_url_equal(iframe.src, iframe_src_value = "https://w.soundcloud.com/player/?url=" + /*soundcloudLink*/
      ctx[0] + "&visual=" + /*showVisual*/
      ctx[3]))
        attr_dev(iframe, "src", iframe_src_value);
      attr_dev(
        iframe,
        "style",
        /*iframe_styles*/
        ctx[5]
      );
      add_location(iframe, file12, 10, 1, 300);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, iframe, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*width*/
      2) {
        attr_dev(
          iframe,
          "width",
          /*width*/
          ctx2[1]
        );
      }
      if (dirty & /*height*/
      4) {
        attr_dev(
          iframe,
          "height",
          /*height*/
          ctx2[2]
        );
      }
      if (dirty & /*soundcloudLink*/
      1 && iframe_title_value !== (iframe_title_value = `soundcloud-${/*soundcloudLink*/
      ctx2[0]}`)) {
        attr_dev(iframe, "title", iframe_title_value);
      }
      if (dirty & /*soundcloudLink, showVisual*/
      9 && !src_url_equal(iframe.src, iframe_src_value = "https://w.soundcloud.com/player/?url=" + /*soundcloudLink*/
      ctx2[0] + "&visual=" + /*showVisual*/
      ctx2[3])) {
        attr_dev(iframe, "src", iframe_src_value);
      }
      if (dirty & /*iframe_styles*/
      32) {
        attr_dev(
          iframe,
          "style",
          /*iframe_styles*/
          ctx2[5]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(iframe);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot11.name,
    type: "slot",
    source: "(10:0) <GeneralObserver {disable_observer}>",
    ctx
  });
  return block;
}
function create_fragment12(ctx) {
  let generalobserver;
  let current;
  generalobserver = new general_observer_default({
    props: {
      disable_observer: (
        /*disable_observer*/
        ctx[4]
      ),
      $$slots: { default: [create_default_slot11] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(generalobserver.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(generalobserver.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(generalobserver, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const generalobserver_changes = {};
      if (dirty & /*disable_observer*/
      16)
        generalobserver_changes.disable_observer = /*disable_observer*/
        ctx2[4];
      if (dirty & /*$$scope, width, height, soundcloudLink, showVisual, iframe_styles*/
      111) {
        generalobserver_changes.$$scope = { dirty, ctx: ctx2 };
      }
      generalobserver.$set(generalobserver_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(generalobserver.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(generalobserver.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(generalobserver, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Sound_cloud", slots, []);
  let { soundcloudLink = "" } = $$props;
  let { width = "100%" } = $$props;
  let { height = "300px" } = $$props;
  let { showVisual = true } = $$props;
  let { disable_observer = false } = $$props;
  let { iframe_styles = "" } = $$props;
  const writable_props = [
    "soundcloudLink",
    "width",
    "height",
    "showVisual",
    "disable_observer",
    "iframe_styles"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Sound_cloud> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("soundcloudLink" in $$props2)
      $$invalidate(0, soundcloudLink = $$props2.soundcloudLink);
    if ("width" in $$props2)
      $$invalidate(1, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(2, height = $$props2.height);
    if ("showVisual" in $$props2)
      $$invalidate(3, showVisual = $$props2.showVisual);
    if ("disable_observer" in $$props2)
      $$invalidate(4, disable_observer = $$props2.disable_observer);
    if ("iframe_styles" in $$props2)
      $$invalidate(5, iframe_styles = $$props2.iframe_styles);
  };
  $$self.$capture_state = () => ({
    GeneralObserver: general_observer_default,
    soundcloudLink,
    width,
    height,
    showVisual,
    disable_observer,
    iframe_styles
  });
  $$self.$inject_state = ($$props2) => {
    if ("soundcloudLink" in $$props2)
      $$invalidate(0, soundcloudLink = $$props2.soundcloudLink);
    if ("width" in $$props2)
      $$invalidate(1, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(2, height = $$props2.height);
    if ("showVisual" in $$props2)
      $$invalidate(3, showVisual = $$props2.showVisual);
    if ("disable_observer" in $$props2)
      $$invalidate(4, disable_observer = $$props2.disable_observer);
    if ("iframe_styles" in $$props2)
      $$invalidate(5, iframe_styles = $$props2.iframe_styles);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [soundcloudLink, width, height, showVisual, disable_observer, iframe_styles];
}
var Sound_cloud = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, {
      soundcloudLink: 0,
      width: 1,
      height: 2,
      showVisual: 3,
      disable_observer: 4,
      iframe_styles: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Sound_cloud",
      options,
      id: create_fragment12.name
    });
  }
  get soundcloudLink() {
    throw new Error("<Sound_cloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set soundcloudLink(value) {
    throw new Error("<Sound_cloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Sound_cloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Sound_cloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Sound_cloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Sound_cloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showVisual() {
    throw new Error("<Sound_cloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showVisual(value) {
    throw new Error("<Sound_cloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disable_observer() {
    throw new Error("<Sound_cloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disable_observer(value) {
    throw new Error("<Sound_cloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iframe_styles() {
    throw new Error("<Sound_cloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iframe_styles(value) {
    throw new Error("<Sound_cloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var sound_cloud_default = Sound_cloud;

// node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/spotify.svelte
var file13 = "node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/spotify.svelte";
function create_default_slot12(ctx) {
  let iframe;
  let iframe_title_value;
  let iframe_src_value;
  const block = {
    c: function create() {
      iframe = element("iframe");
      this.h();
    },
    l: function claim(nodes) {
      iframe = claim_element(nodes, "IFRAME", {
        "data-testid": true,
        title: true,
        class: true,
        src: true,
        frameborder: true,
        allow: true,
        style: true
      });
      children(iframe).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(iframe, "data-testid", "spotify");
      attr_dev(iframe, "title", iframe_title_value = `spotify-${/*spotifyLink*/
      ctx[0]}`);
      attr_dev(iframe, "class", "spotify-sveltekit-embed");
      if (!src_url_equal(iframe.src, iframe_src_value = `https://open.spotify.com/embed/${/*spotifyLink*/
      ctx[0]}`))
        attr_dev(iframe, "src", iframe_src_value);
      attr_dev(iframe, "frameborder", "0");
      attr_dev(iframe, "allow", "encrypted-media");
      attr_dev(
        iframe,
        "style",
        /*iframe_styles*/
        ctx[2]
      );
      add_location(iframe, file13, 13, 1, 334);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, iframe, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*spotifyLink*/
      1 && iframe_title_value !== (iframe_title_value = `spotify-${/*spotifyLink*/
      ctx2[0]}`)) {
        attr_dev(iframe, "title", iframe_title_value);
      }
      if (dirty & /*spotifyLink*/
      1 && !src_url_equal(iframe.src, iframe_src_value = `https://open.spotify.com/embed/${/*spotifyLink*/
      ctx2[0]}`)) {
        attr_dev(iframe, "src", iframe_src_value);
      }
      if (dirty & /*iframe_styles*/
      4) {
        attr_dev(
          iframe,
          "style",
          /*iframe_styles*/
          ctx2[2]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(iframe);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot12.name,
    type: "slot",
    source: "(13:0) <GeneralObserver {disable_observer}>",
    ctx
  });
  return block;
}
function create_fragment13(ctx) {
  let generalobserver;
  let current;
  generalobserver = new general_observer_default({
    props: {
      disable_observer: (
        /*disable_observer*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot12] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(generalobserver.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(generalobserver.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(generalobserver, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const generalobserver_changes = {};
      if (dirty & /*disable_observer*/
      2)
        generalobserver_changes.disable_observer = /*disable_observer*/
        ctx2[1];
      if (dirty & /*$$scope, spotifyLink, iframe_styles*/
      37) {
        generalobserver_changes.$$scope = { dirty, ctx: ctx2 };
      }
      generalobserver.$set(generalobserver_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(generalobserver.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(generalobserver.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(generalobserver, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Spotify", slots, []);
  let { spotifyLink = "" } = $$props;
  let { width = "100%" } = $$props;
  let { height = "152px" } = $$props;
  let { disable_observer = false } = $$props;
  let { iframe_styles = `
		border-radius: 0.8rem;
		height: ${height};
		width: ${width};
	` } = $$props;
  const writable_props = ["spotifyLink", "width", "height", "disable_observer", "iframe_styles"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Spotify> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("spotifyLink" in $$props2)
      $$invalidate(0, spotifyLink = $$props2.spotifyLink);
    if ("width" in $$props2)
      $$invalidate(3, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(4, height = $$props2.height);
    if ("disable_observer" in $$props2)
      $$invalidate(1, disable_observer = $$props2.disable_observer);
    if ("iframe_styles" in $$props2)
      $$invalidate(2, iframe_styles = $$props2.iframe_styles);
  };
  $$self.$capture_state = () => ({
    GeneralObserver: general_observer_default,
    spotifyLink,
    width,
    height,
    disable_observer,
    iframe_styles
  });
  $$self.$inject_state = ($$props2) => {
    if ("spotifyLink" in $$props2)
      $$invalidate(0, spotifyLink = $$props2.spotifyLink);
    if ("width" in $$props2)
      $$invalidate(3, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(4, height = $$props2.height);
    if ("disable_observer" in $$props2)
      $$invalidate(1, disable_observer = $$props2.disable_observer);
    if ("iframe_styles" in $$props2)
      $$invalidate(2, iframe_styles = $$props2.iframe_styles);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [spotifyLink, disable_observer, iframe_styles, width, height];
}
var Spotify = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, {
      spotifyLink: 0,
      width: 3,
      height: 4,
      disable_observer: 1,
      iframe_styles: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Spotify",
      options,
      id: create_fragment13.name
    });
  }
  get spotifyLink() {
    throw new Error("<Spotify>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spotifyLink(value) {
    throw new Error("<Spotify>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Spotify>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Spotify>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Spotify>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Spotify>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disable_observer() {
    throw new Error("<Spotify>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disable_observer(value) {
    throw new Error("<Spotify>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iframe_styles() {
    throw new Error("<Spotify>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iframe_styles(value) {
    throw new Error("<Spotify>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var spotify_default = Spotify;

// node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/stackblitz.svelte
var file_1 = "node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/stackblitz.svelte";
function create_default_slot13(ctx) {
  let iframe;
  let iframe_title_value;
  let iframe_src_value;
  const block = {
    c: function create() {
      iframe = element("iframe");
      this.h();
    },
    l: function claim(nodes) {
      iframe = claim_element(nodes, "IFRAME", {
        class: true,
        title: true,
        src: true,
        frameborder: true,
        style: true
      });
      children(iframe).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(iframe, "class", "stackblitz-sveltekit-embed");
      attr_dev(iframe, "title", iframe_title_value = `stackblitz-${/*id*/
      ctx[0]}`);
      if (!src_url_equal(iframe.src, iframe_src_value = /*src*/
      ctx[3]))
        attr_dev(iframe, "src", iframe_src_value);
      attr_dev(iframe, "frameborder", "no");
      iframe.allowFullscreen = true;
      attr_dev(
        iframe,
        "style",
        /*iframe_styles*/
        ctx[2]
      );
      add_location(iframe, file_1, 33, 1, 886);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, iframe, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*id*/
      1 && iframe_title_value !== (iframe_title_value = `stackblitz-${/*id*/
      ctx2[0]}`)) {
        attr_dev(iframe, "title", iframe_title_value);
      }
      if (dirty & /*iframe_styles*/
      4) {
        attr_dev(
          iframe,
          "style",
          /*iframe_styles*/
          ctx2[2]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(iframe);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot13.name,
    type: "slot",
    source: "(33:0) <GeneralObserver {disable_observer}>",
    ctx
  });
  return block;
}
function create_fragment14(ctx) {
  let generalobserver;
  let current;
  generalobserver = new general_observer_default({
    props: {
      disable_observer: (
        /*disable_observer*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot13] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(generalobserver.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(generalobserver.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(generalobserver, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const generalobserver_changes = {};
      if (dirty & /*disable_observer*/
      2)
        generalobserver_changes.disable_observer = /*disable_observer*/
        ctx2[1];
      if (dirty & /*$$scope, id, iframe_styles*/
      32773) {
        generalobserver_changes.$$scope = { dirty, ctx: ctx2 };
      }
      generalobserver.$set(generalobserver_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(generalobserver.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(generalobserver.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(generalobserver, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Stackblitz", slots, []);
  let { width = "100%" } = $$props;
  let { height = "500px" } = $$props;
  let { id = "" } = $$props;
  let { view = "default" } = $$props;
  let { clickToLoad = true } = $$props;
  let { hideNavigation = false } = $$props;
  let { hideExplorer = true } = $$props;
  let { theme = "dark" } = $$props;
  let { file: file19 } = $$props;
  let { disable_observer = false } = $$props;
  let { iframe_styles = `
		height: ${height};
		width: ${width};
	` } = $$props;
  let baseUrl = `https://stackblitz.com/edit/${id}?embed=1`;
  const config2 = {
    ctl: `${clickToLoad ? 1 : 0}`,
    hideExplorer: `${hideExplorer ? 1 : 0}`,
    hideNavigation: `${hideNavigation ? 1 : 0}`,
    theme
  };
  if (view !== "default") {
    config2["view"] = view;
  }
  if (file19) {
    config2["file"] = file19;
  }
  const queryString = new URLSearchParams(config2);
  const src = `${baseUrl}&${queryString.toString()}`;
  $$self.$$.on_mount.push(function() {
    if (file19 === void 0 && !("file" in $$props || $$self.$$.bound[$$self.$$.props["file"]])) {
      console.warn("<Stackblitz> was created without expected prop 'file'");
    }
  });
  const writable_props = [
    "width",
    "height",
    "id",
    "view",
    "clickToLoad",
    "hideNavigation",
    "hideExplorer",
    "theme",
    "file",
    "disable_observer",
    "iframe_styles"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Stackblitz> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(4, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(5, height = $$props2.height);
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("view" in $$props2)
      $$invalidate(6, view = $$props2.view);
    if ("clickToLoad" in $$props2)
      $$invalidate(7, clickToLoad = $$props2.clickToLoad);
    if ("hideNavigation" in $$props2)
      $$invalidate(8, hideNavigation = $$props2.hideNavigation);
    if ("hideExplorer" in $$props2)
      $$invalidate(9, hideExplorer = $$props2.hideExplorer);
    if ("theme" in $$props2)
      $$invalidate(10, theme = $$props2.theme);
    if ("file" in $$props2)
      $$invalidate(11, file19 = $$props2.file);
    if ("disable_observer" in $$props2)
      $$invalidate(1, disable_observer = $$props2.disable_observer);
    if ("iframe_styles" in $$props2)
      $$invalidate(2, iframe_styles = $$props2.iframe_styles);
  };
  $$self.$capture_state = () => ({
    GeneralObserver: general_observer_default,
    width,
    height,
    id,
    view,
    clickToLoad,
    hideNavigation,
    hideExplorer,
    theme,
    file: file19,
    disable_observer,
    iframe_styles,
    baseUrl,
    config: config2,
    queryString,
    src
  });
  $$self.$inject_state = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(4, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(5, height = $$props2.height);
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("view" in $$props2)
      $$invalidate(6, view = $$props2.view);
    if ("clickToLoad" in $$props2)
      $$invalidate(7, clickToLoad = $$props2.clickToLoad);
    if ("hideNavigation" in $$props2)
      $$invalidate(8, hideNavigation = $$props2.hideNavigation);
    if ("hideExplorer" in $$props2)
      $$invalidate(9, hideExplorer = $$props2.hideExplorer);
    if ("theme" in $$props2)
      $$invalidate(10, theme = $$props2.theme);
    if ("file" in $$props2)
      $$invalidate(11, file19 = $$props2.file);
    if ("disable_observer" in $$props2)
      $$invalidate(1, disable_observer = $$props2.disable_observer);
    if ("iframe_styles" in $$props2)
      $$invalidate(2, iframe_styles = $$props2.iframe_styles);
    if ("baseUrl" in $$props2)
      baseUrl = $$props2.baseUrl;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    id,
    disable_observer,
    iframe_styles,
    src,
    width,
    height,
    view,
    clickToLoad,
    hideNavigation,
    hideExplorer,
    theme,
    file19
  ];
}
var Stackblitz = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, {
      width: 4,
      height: 5,
      id: 0,
      view: 6,
      clickToLoad: 7,
      hideNavigation: 8,
      hideExplorer: 9,
      theme: 10,
      file: 11,
      disable_observer: 1,
      iframe_styles: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Stackblitz",
      options,
      id: create_fragment14.name
    });
  }
  get width() {
    throw new Error("<Stackblitz>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Stackblitz>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Stackblitz>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Stackblitz>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Stackblitz>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Stackblitz>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get view() {
    throw new Error("<Stackblitz>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set view(value) {
    throw new Error("<Stackblitz>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clickToLoad() {
    throw new Error("<Stackblitz>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clickToLoad(value) {
    throw new Error("<Stackblitz>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideNavigation() {
    throw new Error("<Stackblitz>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideNavigation(value) {
    throw new Error("<Stackblitz>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideExplorer() {
    throw new Error("<Stackblitz>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideExplorer(value) {
    throw new Error("<Stackblitz>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<Stackblitz>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Stackblitz>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get file() {
    throw new Error("<Stackblitz>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set file(value) {
    throw new Error("<Stackblitz>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disable_observer() {
    throw new Error("<Stackblitz>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disable_observer(value) {
    throw new Error("<Stackblitz>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iframe_styles() {
    throw new Error("<Stackblitz>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iframe_styles(value) {
    throw new Error("<Stackblitz>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var stackblitz_default = Stackblitz;

// node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/toot.svelte
var file14 = "node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/toot.svelte";
function create_fragment15(ctx) {
  let script;
  let script_src_value;
  let t;
  let div;
  let iframe;
  let iframe_src_value;
  const block = {
    c: function create() {
      script = element("script");
      t = space();
      div = element("div");
      iframe = element("iframe");
      this.h();
    },
    l: function claim(nodes) {
      const head_nodes = head_selector("svelte-196w0y8", document.head);
      script = claim_element(head_nodes, "SCRIPT", { src: true, charset: true });
      var script_nodes = children(script);
      script_nodes.forEach(detach_dev);
      head_nodes.forEach(detach_dev);
      t = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      iframe = claim_element(div_nodes, "IFRAME", {
        title: true,
        src: true,
        class: true,
        style: true,
        width: true
      });
      children(iframe).forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      script.async = true;
      if (!src_url_equal(script.src, script_src_value = "https://" + /*instance*/
      ctx[0] + "/embed.js"))
        attr_dev(script, "src", script_src_value);
      attr_dev(script, "charset", "utf-8");
      add_location(script, file14, 8, 1, 239);
      attr_dev(iframe, "title", "");
      if (!src_url_equal(iframe.src, iframe_src_value = "https://" + /*instance*/
      ctx[0] + "/" + /*atUsername*/
      ctx[2] + "/" + /*tootId*/
      ctx[1] + "/embed"))
        attr_dev(iframe, "src", iframe_src_value);
      attr_dev(iframe, "class", "mastodon-embed");
      set_style(iframe, "max-width", "100%");
      set_style(iframe, "border", "0");
      attr_dev(iframe, "width", "400");
      iframe.allowFullscreen = true;
      add_location(iframe, file14, 16, 1, 378);
      attr_dev(div, "class", "flex justify-center mb-12");
      add_location(div, file14, 15, 0, 337);
    },
    m: function mount(target, anchor) {
      append_hydration_dev(document.head, script);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, iframe);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*instance*/
      1 && !src_url_equal(script.src, script_src_value = "https://" + /*instance*/
      ctx2[0] + "/embed.js")) {
        attr_dev(script, "src", script_src_value);
      }
      if (dirty & /*instance, atUsername, tootId*/
      7 && !src_url_equal(iframe.src, iframe_src_value = "https://" + /*instance*/
      ctx2[0] + "/" + /*atUsername*/
      ctx2[2] + "/" + /*tootId*/
      ctx2[1] + "/embed")) {
        attr_dev(iframe, "src", iframe_src_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      detach_dev(script);
      if (detaching)
        detach_dev(t);
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_1($$self, $$props, $$invalidate) {
  let trimmedUsername;
  let atUsername;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Toot", slots, []);
  let { instance: instance19 = "" } = $$props;
  let { username = "" } = $$props;
  let { tootId = "" } = $$props;
  const writable_props = ["instance", "username", "tootId"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Toot> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("instance" in $$props2)
      $$invalidate(0, instance19 = $$props2.instance);
    if ("username" in $$props2)
      $$invalidate(3, username = $$props2.username);
    if ("tootId" in $$props2)
      $$invalidate(1, tootId = $$props2.tootId);
  };
  $$self.$capture_state = () => ({
    instance: instance19,
    username,
    tootId,
    trimmedUsername,
    atUsername
  });
  $$self.$inject_state = ($$props2) => {
    if ("instance" in $$props2)
      $$invalidate(0, instance19 = $$props2.instance);
    if ("username" in $$props2)
      $$invalidate(3, username = $$props2.username);
    if ("tootId" in $$props2)
      $$invalidate(1, tootId = $$props2.tootId);
    if ("trimmedUsername" in $$props2)
      $$invalidate(4, trimmedUsername = $$props2.trimmedUsername);
    if ("atUsername" in $$props2)
      $$invalidate(2, atUsername = $$props2.atUsername);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*username*/
    8) {
      $:
        $$invalidate(4, trimmedUsername = username.trim());
    }
    if ($$self.$$.dirty & /*trimmedUsername*/
    16) {
      $:
        $$invalidate(2, atUsername = trimmedUsername.startsWith("@") ? trimmedUsername : `@${trimmedUsername}`);
    }
  };
  return [instance19, tootId, atUsername, username, trimmedUsername];
}
var Toot = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_1, create_fragment15, safe_not_equal, { instance: 0, username: 3, tootId: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Toot",
      options,
      id: create_fragment15.name
    });
  }
  get instance() {
    throw new Error("<Toot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set instance(value) {
    throw new Error("<Toot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get username() {
    throw new Error("<Toot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set username(value) {
    throw new Error("<Toot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tootId() {
    throw new Error("<Toot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tootId(value) {
    throw new Error("<Toot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var toot_default = Toot;

// node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/tweet.svelte
var file15 = "node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/tweet.svelte";
function create_fragment16(ctx) {
  let script;
  let script_src_value;
  let t0;
  let div;
  let blockquote;
  let a;
  let t1;
  let a_href_value;
  const block = {
    c: function create() {
      script = element("script");
      t0 = space();
      div = element("div");
      blockquote = element("blockquote");
      a = element("a");
      t1 = text("Loading Tweet...");
      this.h();
    },
    l: function claim(nodes) {
      const head_nodes = head_selector("svelte-1jmca8w", document.head);
      script = claim_element(head_nodes, "SCRIPT", { src: true, charset: true });
      var script_nodes = children(script);
      script_nodes.forEach(detach_dev);
      head_nodes.forEach(detach_dev);
      t0 = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      blockquote = claim_element(div_nodes, "BLOCKQUOTE", { class: true });
      var blockquote_nodes = children(blockquote);
      a = claim_element(blockquote_nodes, "A", { class: true, href: true });
      var a_nodes = children(a);
      t1 = claim_text(a_nodes, "Loading Tweet...");
      a_nodes.forEach(detach_dev);
      blockquote_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      script.async = true;
      if (!src_url_equal(script.src, script_src_value = "https://platform.twitter.com/widgets.js"))
        attr_dev(script, "src", script_src_value);
      attr_dev(script, "charset", "utf-8");
      add_location(script, file15, 4, 1, 61);
      attr_dev(a, "class", "twitter-tweet");
      attr_dev(a, "href", a_href_value = `https://twitter.com/${/*tweetLink*/
      ctx[0]}`);
      add_location(a, file15, 13, 2, 249);
      attr_dev(blockquote, "class", "twitter-tweet");
      add_location(blockquote, file15, 12, 1, 212);
      attr_dev(div, "class", "flex justify-center mb-12");
      add_location(div, file15, 11, 0, 171);
    },
    m: function mount(target, anchor) {
      append_hydration_dev(document.head, script);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, blockquote);
      append_hydration_dev(blockquote, a);
      append_hydration_dev(a, t1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*tweetLink*/
      1 && a_href_value !== (a_href_value = `https://twitter.com/${/*tweetLink*/
      ctx2[0]}`)) {
        attr_dev(a, "href", a_href_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      detach_dev(script);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tweet", slots, []);
  let { tweetLink = "" } = $$props;
  const writable_props = ["tweetLink"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Tweet> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("tweetLink" in $$props2)
      $$invalidate(0, tweetLink = $$props2.tweetLink);
  };
  $$self.$capture_state = () => ({ tweetLink });
  $$self.$inject_state = ($$props2) => {
    if ("tweetLink" in $$props2)
      $$invalidate(0, tweetLink = $$props2.tweetLink);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [tweetLink];
}
var Tweet = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment16, safe_not_equal, { tweetLink: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tweet",
      options,
      id: create_fragment16.name
    });
  }
  get tweetLink() {
    throw new Error("<Tweet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tweetLink(value) {
    throw new Error("<Tweet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var tweet_default = Tweet;

// node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/utils/index.js
var config = {
  "1:1": `padding-top: 100%;`,
  "16:9": `padding-top: 56.25%;`,
  "4:3": `padding-top: 75%;`,
  "3:2": `padding-top: 66.66%;`,
  "8.5": `padding-top: 62.5%;`
};
var getPadding = (aspectRatio) => {
  return config[aspectRatio];
};

// node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/vimeo.svelte
var file16 = "node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/vimeo.svelte";
function create_default_slot14(ctx) {
  let div;
  let iframe;
  let iframe_title_value;
  let iframe_src_value;
  let iframe_style_value;
  let div_style_value;
  const block = {
    c: function create() {
      div = element("div");
      iframe = element("iframe");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        "data-testid": true,
        class: true,
        style: true
      });
      var div_nodes = children(div);
      iframe = claim_element(div_nodes, "IFRAME", {
        title: true,
        src: true,
        frameborder: true,
        allow: true,
        style: true
      });
      children(iframe).forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(iframe, "title", iframe_title_value = `vimeo-${/*vimeoId*/
      ctx[0]}`);
      if (!src_url_equal(iframe.src, iframe_src_value = `https://player.vimeo.com/video/${/*vimeoId*/
      ctx[0]}?autoplay=${/*autoPlay*/
      ctx[1]}#t=${/*h*/
      ctx[4]}h${/*m*/
      ctx[5]}m${/*s*/
      ctx[6]}s`))
        attr_dev(iframe, "src", iframe_src_value);
      attr_dev(iframe, "frameborder", "0");
      attr_dev(iframe, "allow", "autoplay; fullscreen");
      iframe.allowFullscreen = true;
      attr_dev(iframe, "style", iframe_style_value = `
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    `);
      add_location(iframe, file16, 20, 2, 499);
      attr_dev(div, "data-testid", "vimeo");
      attr_dev(div, "class", "vimeo-svelte-embed");
      attr_dev(div, "style", div_style_value = `
    	position: relative;
    	width: 100%;
   		${getPadding(
        /*aspectRatio*/
        ctx[2]
      )}
  `);
      add_location(div, file16, 11, 1, 347);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, iframe);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*vimeoId*/
      1 && iframe_title_value !== (iframe_title_value = `vimeo-${/*vimeoId*/
      ctx2[0]}`)) {
        attr_dev(iframe, "title", iframe_title_value);
      }
      if (dirty & /*vimeoId, autoPlay*/
      3 && !src_url_equal(iframe.src, iframe_src_value = `https://player.vimeo.com/video/${/*vimeoId*/
      ctx2[0]}?autoplay=${/*autoPlay*/
      ctx2[1]}#t=${/*h*/
      ctx2[4]}h${/*m*/
      ctx2[5]}m${/*s*/
      ctx2[6]}s`)) {
        attr_dev(iframe, "src", iframe_src_value);
      }
      if (dirty & /*aspectRatio*/
      4 && div_style_value !== (div_style_value = `
    	position: relative;
    	width: 100%;
   		${getPadding(
        /*aspectRatio*/
        ctx2[2]
      )}
  `)) {
        attr_dev(div, "style", div_style_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot14.name,
    type: "slot",
    source: "(11:0) <GeneralObserver {disable_observer}>",
    ctx
  });
  return block;
}
function create_fragment17(ctx) {
  let generalobserver;
  let current;
  generalobserver = new general_observer_default({
    props: {
      disable_observer: (
        /*disable_observer*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot14] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(generalobserver.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(generalobserver.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(generalobserver, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const generalobserver_changes = {};
      if (dirty & /*disable_observer*/
      8)
        generalobserver_changes.disable_observer = /*disable_observer*/
        ctx2[3];
      if (dirty & /*$$scope, aspectRatio, vimeoId, autoPlay*/
      263) {
        generalobserver_changes.$$scope = { dirty, ctx: ctx2 };
      }
      generalobserver.$set(generalobserver_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(generalobserver.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(generalobserver.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(generalobserver, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Vimeo", slots, []);
  let { vimeoId = "" } = $$props;
  let { autoPlay = false } = $$props;
  let { aspectRatio = "16:9" } = $$props;
  let { skipTo = { h: 0, m: 0, s: 0 } } = $$props;
  let { disable_observer = false } = $$props;
  const { h, m, s } = skipTo;
  const writable_props = ["vimeoId", "autoPlay", "aspectRatio", "skipTo", "disable_observer"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Vimeo> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("vimeoId" in $$props2)
      $$invalidate(0, vimeoId = $$props2.vimeoId);
    if ("autoPlay" in $$props2)
      $$invalidate(1, autoPlay = $$props2.autoPlay);
    if ("aspectRatio" in $$props2)
      $$invalidate(2, aspectRatio = $$props2.aspectRatio);
    if ("skipTo" in $$props2)
      $$invalidate(7, skipTo = $$props2.skipTo);
    if ("disable_observer" in $$props2)
      $$invalidate(3, disable_observer = $$props2.disable_observer);
  };
  $$self.$capture_state = () => ({
    getPadding,
    GeneralObserver: general_observer_default,
    vimeoId,
    autoPlay,
    aspectRatio,
    skipTo,
    disable_observer,
    h,
    m,
    s
  });
  $$self.$inject_state = ($$props2) => {
    if ("vimeoId" in $$props2)
      $$invalidate(0, vimeoId = $$props2.vimeoId);
    if ("autoPlay" in $$props2)
      $$invalidate(1, autoPlay = $$props2.autoPlay);
    if ("aspectRatio" in $$props2)
      $$invalidate(2, aspectRatio = $$props2.aspectRatio);
    if ("skipTo" in $$props2)
      $$invalidate(7, skipTo = $$props2.skipTo);
    if ("disable_observer" in $$props2)
      $$invalidate(3, disable_observer = $$props2.disable_observer);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [vimeoId, autoPlay, aspectRatio, disable_observer, h, m, s, skipTo];
}
var Vimeo = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment17, safe_not_equal, {
      vimeoId: 0,
      autoPlay: 1,
      aspectRatio: 2,
      skipTo: 7,
      disable_observer: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Vimeo",
      options,
      id: create_fragment17.name
    });
  }
  get vimeoId() {
    throw new Error("<Vimeo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vimeoId(value) {
    throw new Error("<Vimeo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoPlay() {
    throw new Error("<Vimeo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoPlay(value) {
    throw new Error("<Vimeo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get aspectRatio() {
    throw new Error("<Vimeo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set aspectRatio(value) {
    throw new Error("<Vimeo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get skipTo() {
    throw new Error("<Vimeo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set skipTo(value) {
    throw new Error("<Vimeo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disable_observer() {
    throw new Error("<Vimeo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disable_observer(value) {
    throw new Error("<Vimeo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var vimeo_default = Vimeo;

// node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/you-tube.svelte
var file17 = "node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/you-tube.svelte";
function create_default_slot15(ctx) {
  let div;
  let iframe;
  let iframe_title_value;
  let iframe_src_value;
  let iframe_style_value;
  let div_style_value;
  const block = {
    c: function create() {
      div = element("div");
      iframe = element("iframe");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { style: true });
      var div_nodes = children(div);
      iframe = claim_element(div_nodes, "IFRAME", {
        "data-testid": true,
        title: true,
        src: true,
        frameborder: true,
        allow: true,
        style: true
      });
      children(iframe).forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(iframe, "data-testid", "youTube");
      attr_dev(iframe, "title", iframe_title_value = `youTube-${/*listId*/
      ctx[1].length > 0 ? (
        /*listId*/
        ctx[1]
      ) : (
        /*youTubeId*/
        ctx[0]
      )}`);
      if (!src_url_equal(iframe.src, iframe_src_value = /*src*/
      ctx[5]))
        attr_dev(iframe, "src", iframe_src_value);
      attr_dev(iframe, "frameborder", "0");
      attr_dev(iframe, "allow", "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture");
      iframe.allowFullscreen = true;
      attr_dev(iframe, "style", iframe_style_value = `
	      position: absolute;
  	    top: 0;
    	  left: 0;
      	width: 100%;
      	height: 100%;
				${/*iframe_styles*/
      ctx[4]}
    `);
      add_location(iframe, file17, 27, 2, 803);
      attr_dev(div, "style", div_style_value = `
    	position: relative;
    	width: 100%;
  	  ${getPadding(
        /*aspectRatio*/
        ctx[2]
      )}
  `);
      add_location(div, file17, 20, 1, 702);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, iframe);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*listId, youTubeId*/
      3 && iframe_title_value !== (iframe_title_value = `youTube-${/*listId*/
      ctx2[1].length > 0 ? (
        /*listId*/
        ctx2[1]
      ) : (
        /*youTubeId*/
        ctx2[0]
      )}`)) {
        attr_dev(iframe, "title", iframe_title_value);
      }
      if (dirty & /*iframe_styles*/
      16 && iframe_style_value !== (iframe_style_value = `
	      position: absolute;
  	    top: 0;
    	  left: 0;
      	width: 100%;
      	height: 100%;
				${/*iframe_styles*/
      ctx2[4]}
    `)) {
        attr_dev(iframe, "style", iframe_style_value);
      }
      if (dirty & /*aspectRatio*/
      4 && div_style_value !== (div_style_value = `
    	position: relative;
    	width: 100%;
  	  ${getPadding(
        /*aspectRatio*/
        ctx2[2]
      )}
  `)) {
        attr_dev(div, "style", div_style_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot15.name,
    type: "slot",
    source: "(20:0) <GeneralObserver {disable_observer}>",
    ctx
  });
  return block;
}
function create_fragment18(ctx) {
  let generalobserver;
  let current;
  generalobserver = new general_observer_default({
    props: {
      disable_observer: (
        /*disable_observer*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot15] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(generalobserver.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(generalobserver.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(generalobserver, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const generalobserver_changes = {};
      if (dirty & /*disable_observer*/
      8)
        generalobserver_changes.disable_observer = /*disable_observer*/
        ctx2[3];
      if (dirty & /*$$scope, aspectRatio, listId, youTubeId, iframe_styles*/
      32791) {
        generalobserver_changes.$$scope = { dirty, ctx: ctx2 };
      }
      generalobserver.$set(generalobserver_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(generalobserver.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(generalobserver.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(generalobserver, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("You_tube", slots, []);
  let { youTubeId = "" } = $$props;
  let { listId = "" } = $$props;
  let { autoPlay = false } = $$props;
  let { aspectRatio = "16:9" } = $$props;
  let { skipTo = { h: 0, m: 0, s: 0 } } = $$props;
  let { disable_observer = false } = $$props;
  let { iframe_styles = `
		border-radius: 0.6rem;
	` } = $$props;
  const { h, m, s } = skipTo;
  const tH = h * 60 * 60;
  const tM = m * 60;
  const startTime = tH + tM + s;
  const baseUrl = `https://www.youtube-nocookie.com/embed/`;
  const src = `${baseUrl}${youTubeId.length > 0 ? `${youTubeId}?autoplay=${autoPlay}&start=${startTime}` : `?videoseries?list=${listId}`}`;
  const writable_props = [
    "youTubeId",
    "listId",
    "autoPlay",
    "aspectRatio",
    "skipTo",
    "disable_observer",
    "iframe_styles"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<You_tube> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("youTubeId" in $$props2)
      $$invalidate(0, youTubeId = $$props2.youTubeId);
    if ("listId" in $$props2)
      $$invalidate(1, listId = $$props2.listId);
    if ("autoPlay" in $$props2)
      $$invalidate(6, autoPlay = $$props2.autoPlay);
    if ("aspectRatio" in $$props2)
      $$invalidate(2, aspectRatio = $$props2.aspectRatio);
    if ("skipTo" in $$props2)
      $$invalidate(7, skipTo = $$props2.skipTo);
    if ("disable_observer" in $$props2)
      $$invalidate(3, disable_observer = $$props2.disable_observer);
    if ("iframe_styles" in $$props2)
      $$invalidate(4, iframe_styles = $$props2.iframe_styles);
  };
  $$self.$capture_state = () => ({
    getPadding,
    GeneralObserver: general_observer_default,
    youTubeId,
    listId,
    autoPlay,
    aspectRatio,
    skipTo,
    disable_observer,
    iframe_styles,
    h,
    m,
    s,
    tH,
    tM,
    startTime,
    baseUrl,
    src
  });
  $$self.$inject_state = ($$props2) => {
    if ("youTubeId" in $$props2)
      $$invalidate(0, youTubeId = $$props2.youTubeId);
    if ("listId" in $$props2)
      $$invalidate(1, listId = $$props2.listId);
    if ("autoPlay" in $$props2)
      $$invalidate(6, autoPlay = $$props2.autoPlay);
    if ("aspectRatio" in $$props2)
      $$invalidate(2, aspectRatio = $$props2.aspectRatio);
    if ("skipTo" in $$props2)
      $$invalidate(7, skipTo = $$props2.skipTo);
    if ("disable_observer" in $$props2)
      $$invalidate(3, disable_observer = $$props2.disable_observer);
    if ("iframe_styles" in $$props2)
      $$invalidate(4, iframe_styles = $$props2.iframe_styles);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    youTubeId,
    listId,
    aspectRatio,
    disable_observer,
    iframe_styles,
    src,
    autoPlay,
    skipTo
  ];
}
var You_tube = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment18, safe_not_equal, {
      youTubeId: 0,
      listId: 1,
      autoPlay: 6,
      aspectRatio: 2,
      skipTo: 7,
      disable_observer: 3,
      iframe_styles: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "You_tube",
      options,
      id: create_fragment18.name
    });
  }
  get youTubeId() {
    throw new Error("<You_tube>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set youTubeId(value) {
    throw new Error("<You_tube>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get listId() {
    throw new Error("<You_tube>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set listId(value) {
    throw new Error("<You_tube>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoPlay() {
    throw new Error("<You_tube>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoPlay(value) {
    throw new Error("<You_tube>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get aspectRatio() {
    throw new Error("<You_tube>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set aspectRatio(value) {
    throw new Error("<You_tube>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get skipTo() {
    throw new Error("<You_tube>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set skipTo(value) {
    throw new Error("<You_tube>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disable_observer() {
    throw new Error("<You_tube>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disable_observer(value) {
    throw new Error("<You_tube>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iframe_styles() {
    throw new Error("<You_tube>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iframe_styles(value) {
    throw new Error("<You_tube>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var you_tube_default = You_tube;

// node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/zencastr.svelte
var file18 = "node_modules/.pnpm/sveltekit-embed@0.0.13_svelte@3.59.1/node_modules/sveltekit-embed/dist/components/zencastr.svelte";
function create_fragment19(ctx) {
  let section;
  let blockquote;
  let img;
  let t0;
  let a;
  let t1;
  let a_href_value;
  let blockquote_data_episode_href_value;
  const block = {
    c: function create() {
      section = element("section");
      blockquote = element("blockquote");
      img = element("img");
      t0 = space();
      a = element("a");
      t1 = text("View on Zencastr");
      this.h();
    },
    l: function claim(nodes) {
      section = claim_element(nodes, "SECTION", { style: true });
      var section_nodes = children(section);
      blockquote = claim_element(section_nodes, "BLOCKQUOTE", {
        class: true,
        "data-episode-href": true,
        style: true
      });
      var blockquote_nodes = children(blockquote);
      img = claim_element(blockquote_nodes, "IMG", { alt: true, style: true });
      t0 = claim_space(blockquote_nodes);
      a = claim_element(blockquote_nodes, "A", {
        href: true,
        target: true,
        rel: true,
        style: true
      });
      var a_nodes = children(a);
      t1 = claim_text(a_nodes, "View on Zencastr");
      a_nodes.forEach(detach_dev);
      blockquote_nodes.forEach(detach_dev);
      section_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(img, "alt", "");
      set_style(img, "width", "120px");
      set_style(img, "display", "inline-block");
      set_style(img, "position", "absolute");
      set_style(img, "top", "calc(50%)");
      set_style(img, "left", "calc(50%)");
      set_style(img, "transform", "translate(-50%, -50%)");
      add_location(img, file18, 16, 2, 593);
      attr_dev(a, "href", a_href_value = `https://zencastr.com/embed/${/*zencastrId*/
      ctx[0]}`);
      attr_dev(a, "target", "_blank");
      attr_dev(a, "rel", "noopener noreferrer");
      set_style(a, "color", "white");
      set_style(a, "position", "absolute");
      set_style(a, "bottom", "12px");
      set_style(a, "left", "50%");
      set_style(a, "transform", "translateX(-50%)");
      set_style(a, "text-decoration", "none");
      add_location(a, file18, 20, 2, 750);
      attr_dev(blockquote, "class", "zenplayer");
      attr_dev(blockquote, "data-episode-href", blockquote_data_episode_href_value = `https://zencastr.com/embed/${/*zencastrId*/
      ctx[0]}`);
      set_style(blockquote, "background", "black");
      set_style(blockquote, "border-radius", "12px");
      set_style(blockquote, "font-family", "system-ui");
      set_style(blockquote, "width", "480px");
      set_style(blockquote, "height", "480px");
      set_style(blockquote, "position", "relative");
      set_style(blockquote, "color", "white");
      set_style(blockquote, "margin", "0");
      add_location(blockquote, file18, 11, 1, 343);
      set_style(section, "display", "flex");
      set_style(section, "justify-content", "center");
      add_location(section, file18, 10, 0, 285);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, section, anchor);
      append_hydration_dev(section, blockquote);
      append_hydration_dev(blockquote, img);
      append_hydration_dev(blockquote, t0);
      append_hydration_dev(blockquote, a);
      append_hydration_dev(a, t1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*zencastrId*/
      1 && a_href_value !== (a_href_value = `https://zencastr.com/embed/${/*zencastrId*/
      ctx2[0]}`)) {
        attr_dev(a, "href", a_href_value);
      }
      if (dirty & /*zencastrId*/
      1 && blockquote_data_episode_href_value !== (blockquote_data_episode_href_value = `https://zencastr.com/embed/${/*zencastrId*/
      ctx2[0]}`)) {
        attr_dev(blockquote, "data-episode-href", blockquote_data_episode_href_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(section);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Zencastr", slots, []);
  let { zencastrId = "" } = $$props;
  onMount(() => {
    const script = document.createElement("script");
    script.async = true;
    script.src = "https://zencastr.com/static/js/embed-player.js";
    document.body.appendChild(script);
  });
  const writable_props = ["zencastrId"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Zencastr> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("zencastrId" in $$props2)
      $$invalidate(0, zencastrId = $$props2.zencastrId);
  };
  $$self.$capture_state = () => ({ onMount, zencastrId });
  $$self.$inject_state = ($$props2) => {
    if ("zencastrId" in $$props2)
      $$invalidate(0, zencastrId = $$props2.zencastrId);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [zencastrId];
}
var Zencastr = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment19, safe_not_equal, { zencastrId: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Zencastr",
      options,
      id: create_fragment19.name
    });
  }
  get zencastrId() {
    throw new Error("<Zencastr>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zencastrId(value) {
    throw new Error("<Zencastr>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var zencastr_default = Zencastr;
export {
  anchor_fm_default as AnchorFm,
  buzzsprout_default as Buzzsprout,
  code_pen_default as CodePen,
  deezer_default as Deezer,
  general_observer_default as GeneralObserver,
  generic_embed_default as GenericEmbed,
  gist_default as Gist,
  guild_default as Guild,
  relive_default as Relive,
  simple_cast_default as SimpleCast,
  slides_default as Slides,
  sound_cloud_default as SoundCloud,
  spotify_default as Spotify,
  stackblitz_default as StackBlitz,
  toot_default as Toot,
  tweet_default as Tweet,
  vimeo_default as Vimeo,
  you_tube_default as YouTube,
  zencastr_default as Zencastr
};
//# sourceMappingURL=sveltekit-embed.js.map
